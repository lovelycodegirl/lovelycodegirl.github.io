<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>前端基础知识点整理 | </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="HTML和CSSH5">
<meta property="og:type" content="article">
<meta property="og:title" content="前端基础知识点整理">
<meta property="og:url" content="http://yoursite.com/2017/12/05/前端基础知识点/index.html">
<meta property="og:site_name">
<meta property="og:description" content="HTML和CSSH5">
<meta property="og:updated_time" content="2017-12-08T07:47:09.177Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="前端基础知识点整理">
<meta name="twitter:description" content="HTML和CSSH5">
  
    <link rel="alternate" href="/atom.xml" title="" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo"></a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">猫猫的爬坑路</a>
        
          <a class="main-nav-link" href="/archives">碎碎念</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Buscar"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-前端基础知识点" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/12/05/前端基础知识点/" class="article-date">
  <time datetime="2017-12-05T07:38:10.332Z" itemprop="datePublished">2017-12-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      前端基础知识点整理
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>HTML和CSS<br>H5<br><a id="more"></a><br>兼容性处理<br>    创建一个这个标签.<br>    使用html5shiv.js    搭配 cc:ie6条件注释<br>表单类型<br>两个事件<br>    oninput:当表单的值发生改变时立即出发。（HTML5新增）<br>    onchange:当表单的值发生改变并且失去焦点的时候触发。<br>表单验证<br>    email  <input type="email">   email类型，在提交表单时，会验证表单的内容（只能初略的验证）<br>    url  <input type="url">  url类型<br>    require  <input type="text" require="">  非空校验<br>    pattern  <input type="text" pattern="[1-9]\d{4,10}">   自定义规则<br>其他表单属性<br>         autocomplete   <input type="text" autocomplete="off" name="age">  自动补全，默认为on，值为off的时候表示关闭，一定要有name属性才生效。<br>        multiple   <input type="file" multiple>   支持多个文件上传<br>        form   <input type="text " form="myForm">  配合form表单的id进行关联，让input框可以写在任意位置。<br>        list   <input type="text " list="myList">  配合datalist使用<br>音频<br>    <audio src="./music/rain.mp3" controls loop autoplay></audio><br>    autoplay 自动播放<br>    controls 是否显不默认播放控件<br>    loop 循环播放<br>视频<br>    <video src="./video/video.mp4" controls loop autoplay></video><br>    autoplay 自动播放<br>    controls 是否显不默认播放控件<br>    loop 循环播放<br>     poster:视频没有播放的时候的预览图片，海报<br>音视频常用的几个方法<br>    play:控制视频播放<br>    pause：控制视频暂停<br>    load：重新载入视频<br>    width:设置播放窗口的宽度或者高度    只用设置一个  ,会等比例缩放<br>获取元素的新方法<br>    根据类型查找元素，返回一个伪数组,document.getElementsByClassName(“className”)<br>    通过css选择器获取元素，返回符合要求的第一个元素,注意返回结果是对象 document.querySelector(“css选择器”)<br>    通过css选择器获取元素，返回伪数组  document.querySelectorAll(“css选择器”)<br>类名操作<br>    添加类  node.classList.add(“classname”);<br>    移除类  node.classList.remove(“classname”);<br>    切换类   node.classList.toggle(“classname”);<br>    判断类  node.classList.contains(“classname”);<br>自定义属性，其格式如下data-*=””<br>1、读取 demo.dataset[‘name’] 或者 demo.dataset[‘age’]<br>2、设置demo.dataset[‘name’] = ‘web developer’<br>3、demo.dataset[‘userName’]//如果-比较多，需要转换成驼峰命名法。<br>进度条有很大的兼容性</p>
<p><progress value="50" min="0" max="100"></progress></p>
<p><meter value="30" min="0" max="100" low="20" high="80"></meter><br>网络状态 navigator.onLine<br>    返回用户当前的网络状况，是一个布尔值     true 为在线状态<br>    false  如果浏览器连不上网(包括局域网),就是离线(脱机)状态.<br>用户地理信息<br>    HTML5规范提供了一套保护用户隐私的机制。必须先得到用户明确许可，才能获取用户的位置信息。在获取地理位置之前，会询问用户，只有在获得许可之后，才能获取到用户的位置信息。<br>       获取当前的地理位置信息    navigator.geolocation.getCurrentPosition(successCallback, errorCallback)<br>      重复的获取当前的地理位置信息 navigator.geolocation.watchPosition(successCallback, errorCallback)<br>cookie<br>    使用cookie：操作太麻烦，最多只能存储4k ,每次请求都会带上cookie，所以用户名和密码、还有sessionID会存储在cookie中<br>    是以字符串形式存在的,这个字符串有固定的格式,  key=value; key1=value1<br>    在获取cookie内容时，一般需要通过正则或者字符串的方法进行处理，转换成对象，最终得到数据。<br>    使用jQuery.cookie插件操作cookie<br>window.sessionStorage的特点</p>
<pre><code>1. 声明周期为关闭浏览器窗口
2. 不能在多个窗口下共享数据。
3. 大小为5M
</code></pre><p>window.localStorage的方法</p>
<pre><code>1. 永久生效，除非手动删除
2. 可以多个窗口共享
3. 大小为20M 大小为5M左右
</code></pre><p>window.sessionStorage与window.localStorage的方法<br>    setItem(key, value) //设置存储内容<br>    getItem(key) //读取存储内容<br>    removeItem(key) //删除键值为key的存储内容<br>    clear() //清空所有存储内容<br>    key(n) //以索引值来获取存储内容<br>FileReader对象   用于读取文件<br>拖拽元素<br>    页面中设置了draggable=”true”  属性的元素,器中img a标签默认是可以被拖拽的.<br>拖拽元素<br>    ondrag  应用于拖拽元素,整个拖拽过程中都会调用<br>    ondragstart    应用于拖拽元素,当拖拽开始调用<br>    ondragend  应用于拖拽元素,当拖拽结束时调用<br>目标元素<br>    ondragover 应用于目标元素,当停留在目标元素上时调用<br>    ondrop  应用于目标元素,当在目标元素上松开鼠标时调用.<br>CSS3<br>PC端浏览器支持程度差，需要添加私有前缀<br>私有前缀<br>    谷歌、苹果浏览器：-webkit-<br>    火狐浏览器：-moz-<br>    IE浏览器：-ms-<br>    欧朋浏览器：-o-<br>css3选择器<br>    关系选择器<br>        DIV&gt;P   子代选择器,选择div的子级中的所有p标签<br>        div p 后代选择器  选择div后代中所有p标签<br>        div+p  相邻选择器   选择紧跟着div后面的p标签<br>        div~p   兄弟选择器,选择div后面的所有兄弟元素中的p标签<br>    属性选择器<br>        li[skill]   选择拥有skill属性的元素<br>        li[skill=”val”]       选择拥有skill属性,并且值为val的元素<br>        li[skill^=”val”]     选择拥有skill属性,并且值以val开头的元素<br>        li[skill$=”val”]     选择拥有skill属性,并且值以val结尾的元素<br>        li[skill^=”val”]     选择拥有skill属性,并且值包含val的元素<br>    伪类选择器<br>        child系列<br>            li:first-child    匹配的是li 的父元素ul的第一个子元素<br>            li:last-child    匹配的是li 的父元素ul的最后一个子元素<br>            li:nth-child  (1)  匹配的是li 的父元素ul中的指定下标的子元素(下标从1开始)<br>            li:nth-child  (odd)  匹配的是li 的父元素ul中的奇数的子元素(下标从1开始)<br>            li:nth-child  (2n)  n从0 开始计算,2n代表的是偶数,2n+1代表的是奇数<br>    伪元素选择器<br>        before和after<br>             必须指定content属性，可以在content属性中写入文本内容，但是通常为空字符串。<br>            默认是行内元素，无法设置宽高，需要指定display:block或者position:absolute<br>            E::before :在元素子节点的最前面添加一个内容。<br>            E::after  :在元素子节点的最后面添加一个内容。<br>css颜色<br>    opacity    如果给父盒子设置opacity，所有的子盒子都会有这个效果，opacity存在兼容性问题，如果是在IE678下，应该使用filter进行设置<br>    解决盒子继承透明度继承的方法<br>        如果是纯色的背景，可以是使用rgba<br>        如果是图片，可以脱离父子关系，让后用定位的方式来做。<br>     rgba<br>        R:Red、G:Green、B:Blue、A:Alpha，R、G、B 取值范围0~255，A的取值范围是0-1<br>        RGBA可以用于所有使用颜色的地方<br>        rgb三个值越小，颜色越黑<br>    hsla<br>        H 色调 取值范围0~360，0/360表示红色、120表示绿色、240表示蓝色<br>        S 饱和度取值范围0%~100%<br>        L 亮度 取值范围0%~100%<br>        A 透明度取值范围0~1<br>        background-color: hsla(120,100%,50%,1);<br>标准盒模型 ： 盒子的大小 = width + padding + border<br>怪异盒模型   width=content+padding + border<br>文字阴影 ： text-shadow：水平偏移 垂直偏移 羽化大小 颜色<br>边框阴影  :box-shadow    水平偏移 垂直偏移 羽化大小   阴影外延值  颜色  inset(设置对象的阴影类型为内阴影).<br>边框圆角 border-radius<br>边框图片 border-images(兼容性很严重)<br>    border-image-source:url( )   指定图片的地址<br>    border-image-slice:27   指定图片的切割方式<br>    border-image-repeat: round(  )   repeat(  )  指定图片的平铺方式<br>    border-image-width:     指定边框的大小<br>    border-images-outset:   指定边框与内容之间的间隙<br>    合写  border-image: url(“images/border01.png”) 27 repeat;<br>背景  background<br>    background-size 设置背景图片的尺寸大小<br>        background-size:600px 400px;  设置图片的大小<br>        background-size:100% 100%   百分比是相对于盒子自身的宽度和高度<br>        background-size:contain  保证等比例缩放,但是会出现留白<br>        background-size:cover   保证等比例缩放,并且不会留白,但是出现有一部分图片不显示<br>    background-clip   设置背景区域的大小<br>        盒子的背景区域是整个盒子,包括边框和padding<br>        background-clip:border-box   设置背景区域包括了边框<br>        background-clip:padding-box;   背景区域只包含padding和content<br>        background-clip:content-box;   背景区域只包含content<br>    background-origin 设置圆点位置,默认是padding的地方开始<br>        background-origin: border-box;  设置原点从border开始<br>        background-origin: padding-box;   设置原点从padding开始,默认值<br>        background-origin: content-box;     设置原点从content开始<br>    多重背景<br>        background设置背景的时候，可以设置多个背景图片，使用逗号隔开。注意颜色只能设置一次，并且通常来说，颜色都是在最后面进行设置。<br>渐变实际上相当于一张图片,因为需要加给background-image才会生效<br>渐变的两个要求:   有区间,有颜色变化.<br>   渐变  linear-gradient和radial-gradient<br>    渐变实际上相当于一张图片,因为需要加给background-image才会生效<br>    line-gradient   线性渐变<br>         background: linear-gradient(red, blue);   (默认)是从上向下<br>         background: linear-gradient(to right    red, blue);    从左到右的线性渐变<br>         background: linear-gradient(to   bottom right  ,  red, blue);    从左上角到右上角<br>         background: linear-gradient(45deg,   red, blue);   使用角度渐变<br>         background: linear-gradient(pink,    red, blue);    使用多个颜色节点<br>         background: linear-gradient(to right ,rgba(255,0,0,0), rgba(255,0,0,1);   使用透明度<br>        background-image: linear-gradient(to right, red 20%, green 80%)  设定渐变的范围<br>        background-image: linear-gradient(to right, red 20%, green 20%)  每一个区间表示渐变颜色的范围<br>    radial-gradient   径向渐变<br>        background-image: radial-gradient(red, green);   颜色结点均匀分布<br>        background-image: radial-gradient(200px at center(top  left)r, red, green);   设置圆的半径和圆心<br>        background-image: radial-gradient(200px 80px at center, red, green);  指定椭圆<br>        background-image: radial-gradient(200px at center, green 50%, red 50%);    指定范围<br>过渡   transition<br>    是c3中具有颠覆性的特征之一,可以实现元素不同状态间的平滑过渡(补间动画.)<br>    transition-property:all;   设置过渡属性<br>    transition-duration:2s;  设置过渡时间<br>    transition-delay:2s;  设置过渡延时.<br>    transtion-timing-function:linear,ease,ease-in,ease-out,ease-in-out,steps   设置过渡的类型<br>    属性合写:  属性  持续时间   延时 速度<br>    过渡的注意点:<br>        过渡必须要有两个状态的变化.<br>        过渡可以写在a状态,也可以写在B状态,但是如果写在B 状态,俺么回来的时候就没有过渡效果了<br>2d转换  transform<br>    transform: 转换，是CSS3最具颠覆性的几个特性之一，既可以用于2D转换，也可以用于3D转换。<br>    scale    缩放<br>        transform: scaleX(0.5);//让宽度变化<br>        transform: scaleY(0.5);//让高度变化，注意不能写多个transform，不然会覆盖。<br>        transform: scale(0.5);//让宽度和高度同时变化<br>        注意<br>            scale接收的值是倍数，因此没有单位<br>            scale可以是一个值，如果是一个值，不是说仅仅缩放宽度，高度也会等比例的缩放。<br>            可以通过transform-origin设定旋转原点<br>    translate  平移<br>        transform: translateX(100px);<br>        transform: translateY(100px);<br>        transform: translate(100px, 100px);<br>        transform: translate(50%, 50%);<br>        注意<br>             translate的值可以是px，也可以是百分比，如果是百分比，那么参照的是自身的宽高。<br>            translate移动的元素并不会影响其他盒子，类似于相对定位。<br>    rotate   旋转<br>        transform: rotate(360deg);//旋转360度<br>        transform: rotate(-360deg);//逆时针旋转360度<br>        注意<br>            单位是deg，角度，不是px<br>            正值顺时针转，负值逆时针转<br>            可以通过transform-origin设定旋转原点<br>            转换原点写在A状态，不能写在B状态<br>    skew   斜切  扭曲<br>        skew在实际开发中，是用的最少的一个属性。一般来说，x和y只会倾斜其中的一个<br>        transform: skewX(30deg);   在水平方向倾斜30deg<br>        transform: skewY(30deg);  在垂直方向倾斜30deg<br>    transform-origin  转换原点<br>        transform-origin: center center;<br>        transform-origin: 40px 40px;<br>    转换合写问题<br>        transform:translateX(800px) scale(1.5) rotate(360deg) ;</p>
<pre><code>1. transform属性只能写一个，如果写了多个会覆盖
2. transform属性可以连写，但是顺序对效果影响的，因为它会在第一个效果的基础上执行第二个效果，然后执行第三个效果（通常会把rotate放后面）
3. 如果对transform进行过度效果的时候，初始状态和结束状态一一对应
</code></pre><p>rotate   旋转<br>    transform: rotate(45deg);// 让元素在平面2D中旋转<br>    transform: rotateX(45deg);// 让元素沿着X轴转45度<br>    transform: rotateY(45deg);// 让元素沿着Y轴转45度<br>    transform: rotateZ(45deg);// 让元素沿着Z轴转45度<br>3d转换   transform<br>    rotate   旋转<br>        transform: rotate(45deg);// 让元素在平面2D中旋转<br>        transform: rotateX(45deg);// 让元素沿着X轴转45度<br>        transform: rotateY(45deg);// 让元素沿着Y轴转45度<br>        transform: rotateZ(45deg);// 让元素沿着Z轴转45度<br>    perspective透视</p>
<pre><code>           1. 在视觉上，能够产生近远小的效果。 房子的真实大小是一样，仅仅是在视觉上会有一个近大远小的效果。
              2. perspective：给父元素添加
              3. 1000px：视距   眼睛距离物体的一个距离，值越大，近大远小的效果越不明显，视距越小，近大远小的效果就越明显，
transform-style
    flat:默认值，2d显示
    preserve-3d: 3d显示
    transform-style与perspective的区别
        /*透视：透视只是相当于设置了一个距离，辅助我们查看3D效果的工具，*/
        /*preserve-3d:给父盒子添加，让子元素保留3D的位置，说白了，只有设置了preserve-3d，这个元素才能被称之为3d元素。 */
        //一个3d元素可以没有perspective，但是不能没有transform-style
backface-visibility
    //指定元素背面面向用户时是否可见。 
    //visible： 指定元素背面可见，允许显示正面的镜像。 
    //hidden： 指定元素背面不可见 
    //注意：只有在3d的情况下，backface-visibility才会生效
</code></pre><p>动画  animation<br>    动画也是CSS3中具有颠覆性的特征之一，可以通过设置多个节点来精确控制一个或者一组动画，常用来实现复杂的动画效果。<br>    动画和过渡的区别  </p>
<pre><code>    1. 过渡必须触发，需要两个状态的改变。
    2. 动画可以一直运行下去，不需要触发。实现效果与过渡差不多
使用动画的基本步骤
    1.通过@keyframes指定动画序列
    2.通过百分比或者from/to将动画分割成多个节点
    3.在各个节点中分别定义动画属性
    4.通过animation将动画应用于相应的元素
animation详解
    animation-name:动画名称，由@keyframes定义的
    animation-duration：动画的持续时间
    animation-timing-function：动画的过渡类型
    animation-delay：动画的延迟时间
    animation-iteration-count：动画的循环次数
    animation-direction：设置动画在循环中是否反向运动
    animation-fill-mode：设置动画时间之外的状态
    animattion-play-state:设置动画的状态。
字体图标
    使用精灵图的缺点   
        1,使用麻烦,需要量位置
        2,精灵图还是需要加载
        3,放大会失真
    iconfont   字体图标
        1.使用方便  
        2,放大不会失真
        3,操作颜色.大小,阴影,非常方便
过渡结束时间  transitionend
</code></pre><p>弹性布局   display:flex<br>    给父盒子添加<br>        display:flex  指定一个盒子是弹性盒子. 弹性盒子就有和主轴和侧轴的概念 默认主轴从左向右 ，默认侧轴从上到下<br>             flex-direction: 修改主轴的方向<br>            row：主轴方向为水平向右<br>            column：主轴方向为竖直向下<br>            row-reverse:主轴方向为水平向左<br>            column-reverse:主轴方向是竖直向上。<br>            justify-content: 设置在主轴方向的对齐方式<br>            flex-start 元素将向起始位置对齐<br>            flex-end: 弹性盒子元素将向结束位置对齐。<br>            center: 弹性盒子元素将向行中间位置对齐<br>            space-around: 弹性盒子元素会平均地分布在行里<br>            space-between:第一个贴左边，最后一个贴右边，其他盒子均分，保证每个盒子之间的空隙是相等的。<br>             不换行: flex-wrap:nowrap<br>                    align-items: 调整不换行的侧轴对其方式  flex-start flex-end center<br>                 换行  : flex-wrap:wrap<br>                    align-content:调整换行的侧轴的对其方式 flex-start flex-end center space-between space-around<br>    给子元素添加<br>               flex: 设置子元素如何分配父元素的空间<br>               order: 设置子元素的排列顺序，值越小，越前<br>               align-self: 设置自身在侧轴的排序顺序<br>3.less的预编译:<br>CSS 需要书写大量看似没有逻辑的代码，不方便维护及扩展，不利于复用。成这些困难的很大原因源于 CSS 是一门非程序式语言，没有变量、函数、SCOPE（作用域）等概念。LESS 为 Web 开发者带来了福音，它在 CSS 的语法基础之上，引入了变量，Mixin（混入），运算以及函数等功能，大大简化了 CSS 的编写，并且降低了 CSS 的维护成本，就像它的名称所说的那样，LESS 可以让我们用更少的代码做更多的事情。本质上，LESS 包含一套自定义的语法及一个解析器，用户根据这些语法定义自己的样式规则，这些规则最终会通过解析器，编译生成对应的 CSS 文件。LESS 并没有裁剪 CSS 原有的特性，更不是用来取代 CSS 的，而是在现有 CSS 语法的基础上，为 CSS 加入程序式语言的特性。<br>1.变量:@director:right;<br>2.mixin混入:混入样式类    混入函数(带参/不带参/带默认参)<br>3.嵌套:&amp;<br>4.导入:@import “01-variable”;<br>5.函数(运算)<br>   .my_btn {<br>  .btn();<br>}<br>.btn_border(@width) {<br>  border: @width solid #000;<br>}<br>    link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。<br>    link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。<br>    ink支持使用Javascript控制DOM去改变样式；而@import不支持。<br>Javascript<br>1.js中的DOM和BOM操作<br>   转换成数字类型:Number() parseInt()  parseFloat()  参与运算<br>   转换成字符串 :tostring()   string()    +””<br>   转换成布尔类型: !!  Boolean()<br>数组<br>    创建数组的两种方式<br>       构造函数创建数组<br>       数组字面量创建数组<br>      取值:数组名[下标]  存值:数组名[下标]=值<br>函数<br>    函数的声明与调用 function函数名(){函数体 }<br>        1,函数声明的时候.函数体并不会执行,只有当函数被调用的时候才会执行.<br>        2,函数一般都用来干一件事情,需要使用动词+名词,表示做一件事”tellStory””sayHello’等<br>       调用函数:函数名();<br>    返回值:函数是用来做一件事情的,如果我们需要这个函数给我们返回一个结果,需要return返回一个值;<br>    函数的三要素: 函数名,参数,返回值.<br>    声明函数的两种方式<br>        命名函数 function 函数名(){} 可以先调用  再声明<br>        匿名函数(函数表达式) function函数也是一种数据类型(复杂数据类型),也可以赋值给一个变量.   先声明 再调用. 匿名函数的好处,不用起名字是如果是只用一次的话.<br>    return<br>        函数名 ()就是调用的结果,其实就是返回值.<br>        函数碰到return就结束了,后面的代码不执行.<br>        函数只有一个返回值,如果需要多个值可以用数组.<br>    作用域</p>
<pre><code>预解析
    提升函数的声明，不提升调用
    先提升var，在提升function
    提升变量的声明，不提升赋值
</code></pre><p>对象<br>        是一系列相关地属性的集合,可以方便对变量和函数进行管理.<br>        事物的特征在对象中用属性来表示,事物的行为在对象中用方法来表示.<br>    创建对象的三种方法<br>        通过对象字面量创建对象.<br>            优点  简洁  容易写.缺点是:复用性差<br>        通过Object构造函数创建了一个空对象.<br>            复用性差<br>        自定义构造函数<br>    构造函数<br>        普通函数创建对象,可以同时创建多个对象,但是创建出来的没有具体的类型,都是object类型<br>        查看对象类型.1;typeof 只能判断基本数据类型2:instanceof 判断对象的具体类型. 3:constructor.name也可以获取到对象的具体类型.<br>        构造函数:是一种特殊的函数,主要用来在创建对象时初始化对象.构造函数用于创建一类对象,首字母要大写,要跟new一起使用才有意义.<br>        new<br>            会新建一个空的对象.这个对象的类型是new后面跟的函数名.<br>            让this指向了这个对象.要个对象加属性和方法,只需要给this加.<br>            执行构造函数.<br>            返回这个对象.<br>    操作对象的属性<br>        .语法<br>        []语法 也叫关联数组语法,当属性名是一个字符串存储在变量中的时候,只能用关联数组的方式.<br>        遍历对象 for(var i in obj){console.log(obj[i])}<br>    值类型与引用类型<br>        值类型:简单数据类型,基本数据类型,在存储时,变量中存储的是值本身,因此叫做值类型<br>        引用类型:复杂数据类型,在存储时,变量存储的仅仅是地址(引用),因此叫做引用类型<br>Jason对象<br>    就是Javascript对象的原生格式,唯一的区别是属性名要用””引起来.<br>arguments对象<br>    在每一个函数里面都自带了这个对象.函数调用的时候会把所有的实参都存起来,是一个伪数组<br>内置对象.<br>String<br>        indexof:获取某个字符串第一次出现的位置,如果没有,返回-1<br>        lastindexof:从后面开始查找第一次出现的位置,如果没有,返回-1<br>            trim();去除字符串两边的空格,内部空格不会去除<br>    大小写转换<br>        toUpperCase：全部转换成大写字母<br>        toLowerCase：全部转换成小写字母<br>    字符串拼接与截取<br>        可以用concat，用法与数组一样，但是字符串拼串我们一般都用+<br>        slice ：从start开始，end结束，并且取不到end。<br>        substring ：从start开始，end结束，并且取不到end<br>        substr ： ：从start开始，截取length个字符。(推荐)<br>    字符串切割<br>        split:将字符串分割成数组（很常用）功能和数组的join正好相反。<br>    字符串替换<br>        replace(searchValue, replaceValue);searchValue:需要替换的值    replaceValue:用来替换的值<br>Array对象<br>        array.join()数据转换<br>        数组的增删操作<br>            array.pop();从数组的后面删除元素,返回删除的那个元素<br>            array.push();从数组后面添加元素,返回新数组的length.<br>            array.unshift();从数组的前面添加元素,返回新数组的长度.<br>            array.shift();从数组的最前面删除元素,返回删除的那个元素<br>        数组的翻转与排序<br>            array.reverse();翻转数组<br>            array.sort();数组的排序,默认按照字母顺序排序<br>        数组的拼接与截取<br>            contact();数组合并,不会影响原来的数组,会返回一个新数组.<br>            slice:数组切分.复制数组的一部分到一个新数组,并返回这个数组,原来的数组不受影响,包含begin,不包含end<br>            splice:数组拼接.以新元素来替代旧元素.以此来修改数组的内容,常用于删除数组的某些项<br>            start:开始位置删除,deleteCount:删除的个数 items:替换的内容<br>        数组查找元素<br>            indexOf 方法来查找某个元素第一次出现的位置,如果找不到,返回-1;<br>            lastIndexOf()从数组后面开始查找数组中元素出现的位置,如果找不到,返回-1;<br>        清空数组<br>            array.splice(0,array.length);删除数组中的所有元素<br>            array.length=0;直接修改数组的长度<br>            array=[ ];将数组赋值为一个空数组<br>    Date对象<br>        var date = new Date();//使用构造函数创建一个当前时间的对象<br>        var year =date.fullyear();获取年份<br>        var year =date.month()+1;     获取月份<br>        var year =date.getDate();获取日期<br>        getMilliseconds();//获取毫秒值<br>        getSeconds();//获取秒<br>        getMinutes();//获取分钟<br>        getHours();//获取小时<br>        时间戳:1970年1月1日00:00:00到现在过得时间秒<br>    Math对象<br>        Math.PI<br>        Math.max/min() ;最大值和最小值<br>        Math.ceil();向上取整  Math.floor()向下取整 Math.round();四舍五入<br>        Math.random();随机数<br>        Math.abs();//求绝对值<br>        Math.pow(num, power);//求num的power次方<br>        Math.sqrt(num);//对num开平方<br>    回调函数;把一个函数当成参数进行传递,我们把这个当成参数的函数叫做回调函数.<br>    递归函数:自己调用自己的函数叫做递归函数.:要留出口<br>DOM:<br>    doucument object model 是操作html和xml的一套api(Application Programer Interface),<br>    节点:dom把页面中所有的东西都封装成了一个个对象,我们把这些对象叫做节点;//标签节点,属性节点,文本节点,注释节点. 元素.标签节点.<br>    console.log()以标签形式.console.dir();以对象的形式打印<br>找对象<br>    通过类名来找 document.getElementsByClassname [0] 返回的永远是一个伪数组<br>    通过标签来找 document.getElementsByTagName[0]<br>    通过ID来找   document.getElementById<br>注册事件<br>     事件源：触发事件的元素   事件名称：触发的事件名称    事件处理函数：触发事件时调用的函数<br>    注册事件的实质:仅仅是对象的onclick绑定了一个函数.<br>    a标签使用return false可以阻止a标签跳转<br>    keyup   拿到最新值<br>    keydown   拿到的是上一次的值<br>表单属性操作<br>        布尔类型的属性    disabled selected checked  只要写了这个属性就生效<br>        常见表单属性  disabled、type、value、checked,selected<br>    自定义属性<br>        getAttribute(name);<br>        setAttribute(name, value);<br>        removeAttribute(name);<br>标签内容<br>    innerText 和innerhtml属性都是用来获取和设置标签的内容.<br>    innerHTML:设置内容的时候，1. 会覆盖原来的内容 2. 标签能生效<br>    innerText设置内容的时候，会对html标签进行转义。1. 会覆盖原来的内容， 2. 把标签当成文本用了。防止xss攻击<br>innerText 和innerhtml属性都是用来获取和设置标签的内容.<br>解决浏览器兼容性的处理<br>    能力检测(常用)检测某个方法或者某个属性是否可用,如果可用就使用<br>    代理检测  通过navigator,userAgent可以获取到浏览器的版本信息<br>    怪癖检测<br>节点的常用属性:<br>     nodeType:节点类型<br>    nodeName 节点名称<br>    nodeValue:节点值<br>    javascript:void(0)的作用<br>        javascript:是伪协议，表示url的内容通过javascript执行。<br>        void(0)表示不作任何操作，这样会防止链接跳转到其他页面。<br>         让页面不跳转，JavaScript:void(0)是最通用的方式。<br>    节点:标签节点 文本节点 属性节点 注释节点<br>孩子节点<br>    childNodes:获取所有的孩子节点(基本不用)<br>    children:获取所有的子元素（用途很广泛）<br>    firstElementChild //第一个子元素 有兼容性问题 可以封装一个兼容性方法<br>    //lastElementChild //最后一个子元素 有兼容性问题 可以封装一个兼容性方法<br>兄弟节点<br>    nextSibling:下一个兄弟节点<br>     nextElementSibling:下一个兄弟元素有兼容性问题<br>    previousElementSibling<br>父亲节点<br>        parentNode:父节点  没有兼容性问题\<br>  克隆节点  cloneNode<br>        var newNode = node.cloneNode(deep)参数：deep</p>
<pre><code>    - false：默认值：是浅复制，只会复制标签，节点本身，不会复制节点的孩子。
    - true:深度复制，会复制标签，还会复制标签的所有内容 常用 
添加节点
    appendChild
        作用：把newChild添加到parent的孩子的最后面。
    insertBefore
        语法：parent.insertBefore(newChild, refChild);
        refChild:添加到哪一个节点的前面。
创建节点
    document.write(基本不用)如果页面已经加载完成了，你还是用document.write写内容的话，会把之前的页面给覆盖掉
    innerHTML:创建节点的时候有一个特点，如果原来有内容的话，使用innerHTML会把原先的内容给干掉。  慎用：很容易出现效率问题。
    createElement
        语法：var element = document.createElement(&quot;tagName&quot;);
        作用：在内存里面创建了一个节点
        返回：一个元素
 删除节点      parent.removeChild(child);
</code></pre><p>样式操作<br>    标签有style属性,,dom对象也会有,而且dom的style属性是一个对象<br>    style这个对象中属性值都是字符串格式<br>    标签中style属性有哪些样式名，在style这个对象中就有对应的属性名。<br>    标签中有一些属性带了-，比如background-color,到了style对象中，变成了驼峰命名法，backgroundColor（因为-在js中不是一个合法的标识符）<br>    DOM中的style属性只能获取和设置行内样式，在类样式中定义的样式通过style获取不到。<br>window对象</p>
<pre><code>1. window对象是一个全局对象，也可以说是JavaScript中的顶级对象
2. 像document、alert()、console.log()这些都是window的属性，其实BOM中基本所有的属性和方法都是属性window的。
3. 所有定义在全局作用域中的变量、函数都会变成window对象的属性和方法
4. window对象下的属性和方法调用的时候可以省略window
重谈 this 关键字
    1. this在普通函数中指的是window对象
    2. this在方法中，指定的调用这个方法的对象（对象本身）
    3. this在构造函数中，this指向新创建的对象
    4. this在事件中，指向事件源，即触发事件的对象。
window.open\.close
    //语法：window.open(url, [name], [features]);
    //参数1：需要载入的url地址
    //参数2：新窗口的名称
        //_self:在当前窗口打开
        //_blank:在新的窗口打开
    //参数3：窗口的属性，指定窗口的大小
    //返回值：会返回刚刚创建的那个窗口，用于关闭
window.onload
    会在窗体加载完成后执行，通常我们称之为入口函数。
location对象
    也是window的一个属性，location其实对应的就是浏览器中的地址栏。
    location.href = “http://www.baidu.com”;//让页面跳转到百度首页
    location.reload(true);//强制刷新，相当于ctrl+F5
其他对象
    navigator.userAgent：浏览器版本
    history
        后退：
            history.back();
            history.go(-1);
        前进：
            history.forward();
            history.go(1);
    screen对象
        console.log(screen.width);//屏幕的宽度 
        console.log(screen.height);//屏幕的高度
        console.log(screen.availWidth);//浏览器可占用的宽度
        console.log(screen.availHeight);//浏览器可占用的高度
定时器
    延时定时器setTimeOut(callback, time);
        //参数1：回调函数，时间到了就会执行。
        //参数2：延时的时间
        //返回：定时器的id，用于清除
        清除延时定时器:clearTimeOut(timerId)
    间歇定时器让定时器每隔一段时间就会执行一次，并且会一直执行，直到清除定时器为止.
    间歇定时器
        //语法：var intervalID = setInterval(func, delay);
        //参数1：重复执行的函数
        //参数2：每次延迟的毫秒数
        //返回：定时器的id，用于清除
        清除间歇定时器:clearInterval(intervalID)
</code></pre><p>面向对象：是一种解决问题的思维方式，它的关注点是实现功能的一系列对象<br>面向对象的特性:<br>1.封装性:将功能的具体实现封装在对象内部，只对外界暴露指定的接口，外界在使用的时候，只需要关注接口如何使用，而不需要关心内部的具体实现！这就是封装！<br>2.继承性:一个对象没有一些属性和方法，另外一个对象有，拿过来使用，就是继承！<br>3.多态性:js没有多态性<br>创建对象的方法<br>1.字面量<br>2.构造函数<br>3.自定义构造函数<br>2.2 继承的方法:<br>//1.混入式继承<br>  var obj={<br>    name:”wyh”,<br>    age:18<br>  }<br>  var obj1={}<br>//  for(var k in obj){<br>//    obj1[k]=obj[k]<br>//  }<br>//  console.log(obj1);</p>
<ol>
<li>对象继承<br>var obj1=obj;<br>console.log(obj1);<br>3.原型继承<br>//3.1 使用混入的方式给原型添加属性和方法<br>function Dog(){<br>}<br>function Person () {}<br>//3.2 直接将要继承的对象当作对象的原型<br>function Person () {}<br>var obj1={<br>name:””,<br>age:18<br>}<br>Person.prototype=obj1;<br>var obj=new Person();<br>.经典继承<br>var obj1={<br>name:””,<br>age:18<br>}<br>var obj=new Person();<br>2.3 原型链</li>
</ol>
<p>//使用原型解决构造函数问题<br>function Person(name, age){<br>    this.name = name;<br>    this.age = age;<br>}<br>Person.prototype.sayHi = function(){<br>    console.log(“你好”);<br>};<br>//测试<br>var p = new Person(“张三”, 18);<br>var p1 = new Person(“李四”, 19);<br>console.log(p.sayHi == p1.sayHi); //输出true<br>原型的概念:在构造函数被创建出来的时候，系统会自动的为构造函数创建并且关联一个空对象，这个对象就是原型<br>原型的作用:原型是一个对象,这个对象中的所有的方法和属性都可以被和他关联的构造韩式所创建出来的所有的对象共享<br>原型链:对象都有原型，原型也是对象，所以原型也有原型，这样子就会形成一个原型组成的链式结构，称作原型链<br>原型的访问形式:构造函数.prototype     对象.<strong>proto</strong>(有兼容性的问题,不推荐使用)<br>原型的使用:<br>1.原型中一般会放一些需要被共享的内容,方法(行为)居多,属性一般不做共享<br>2.当使用对象访问某一个属性的时候,会先在对象自身进行查找，如果找到了就直接使用，如果没有找，就会去原型中进行查找<br>3.当使用对象为某个属性进行赋值操作的时候，不会去原型中查找，只会看对象自身有没有该属性，如果有，就将值修改，如果没有，就给该对象新增该属性！<br>4.当对构造函数的prototype属性赋值的时候，赋值之前创建的对象，和赋值之后创建的对象的原型会不一致！<br>作用域:作用域说明的是一个变量可以在什么地方被使用，什么地方不能被使用。<br>词法作用域:<br>访问的变量，只和当前代码的声明结构有关，和具体的调用，运行没有任何的关系<br>只要声明的方式确定，那么访问的变量就确定了，这就是词法作用域的效果<br>块级作用域<br>2.5 闭包<br>什么是闭包？闭包的优缺点？<br>由于在javascript中，只有函数内部的子函数才能读取局部变量，所以说，闭包可以简单理解成“定义在一个函数内部的函数“。所以，在本质上，闭包是将函数内部和函数外部连接起来的桥梁。<br>闭包的用途<br>一个是前面提到的可以读取函数内部的变量.<br>一个就是让这些变量的值始终保持在内存中，不会在f1调用后被自动清除。<br>使用闭包的注意点<br>（1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。<br>（2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。<br>2.6 数组的高级方法</p>
<p>//forEach<br>//map  有返回值,数组<br>//every  所有的都要满足返回<br>//some   有一个满足返回<br>//filter<br>2.7 函数的调用模式<br>//函数名()<br>//方法调用模式()<br>//构造函数()<br>//上下文调用()<br>2.8 将伪数组转换为真数组 </p>
<p>说说写JavaScript的基本规范？<br>1.不要在同一行声明多个变量</p>
<p>2.请使用 ===/!==来比较true/false</p>
<p>3.使用字面量代替new Array（）</p>
<p>4.不要使用全局函数</p>
<p>5.Switch必须使用default</p>
<p>6.函数不应该有时候有返回值，有时候没有返回值（建议最好都要有返回值:undefined）</p>
<p>7.for循环和if语句必须使用花括</p>
<p>8.for in 循环中的变量 应该使用var 关键字限定作用域，从而避免作用域污染</p>
<p>JavaScript原型，原型链 ? 有什么特点？<br>当构造函数被创建出来的时候,系统会自动为这构造函数创建并关联一个空对象,这个空对象就是原型,原型可以挂载属性和方法,原型里面的属性和方法可以被构造函数创建出来的对象所共享和访问;<br>原型的值也可以是一个对象,则这个对象值也是一个原型,就这样形成了一个线性链,我们称他为原型链;<br>JavaScript有几种类型的值？（堆：原始数据类型和 栈：引用数据类型），你能画一下他们的内存图吗？<br>·<br>·<br>Javascript如何实现继承？<br>混入式继承;原型继承;经典继承;对象继承;<br>Javascript创建对象的几种方式？<br>1:对象字面量<br>2.通过object构造函数<br>3:自定义构造函数<br>Javascript作用链域?<br>函数可以创建作用域,函数也可以声明函数,这样就形成了作用域链嵌套作用域自内向外访问的结构,称为作用域链;<br>谈谈This对象的理解。<br>在普通函数和定时器中this指向的是window;在构造函数中,this指的是实例化对象; 在事件触发中,this指的是事件触发的对象;<br>eval是做什么的？<br>把字符串参数解析成JS代码并运行，并返回执行的结果；<br>什么是window对象? 什么是document对象?<br>    简单来说，document对象是window对象的一个属性，是显示于窗口内的一个文档。而window对象则是一个顶层对象，它不是另一个对象的属性。document可以理解为文档，就是你的网页，而window是你的窗口，就是你的浏览器包含的。它们俩在没有框架的情况下可以说是等同的，在有框架的情况下就要区别对待了。<br>null，undefined的区别？<br>null是一个空的对象,undefined是一个未定义的值;<br>写一个通用的事件侦听器函数(机试题)。<br>·<br>·<br>[“1”, “2”, “3”].map(parseInt) 答案是多少？<br>1.NaN,NaN<br>关于事件，IE与火狐的事件机制有什么区别？ 如何阻止冒泡？<br>事件机制<br>事件冒泡：事件从当前元素对象触发，然后向上层元素搜索相同对象事件并触发（直搜到document节点）。IE事件默认都只这种类型的事件。<br>事件捕获：从document节点开始搜索事件，然后向下层搜索相同对象事件并触发，直到当前元素节点<br>阻止事件冒泡的方法<br>ie支持事件冒泡<br>火狐支持 捕获和冒泡两种<br>w3c支持 e.stopPropagation()，IE则是使用e.cancelBubble = true</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/12/05/前端基础知识点/" data-id="cjbxfi1fz0004m18usy8dqp5u" class="article-share-link">Compartir</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2017/12/11/life/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Nuevo</strong>
      <div class="article-nav-title">
        
          life
        
      </div>
    </a>
  
  
    <a href="/2016/12/11/Jquery/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Viejo</strong>
      <div class="article-nav-title">Jquery</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archivos</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/09/">September 2015</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Posts recientes</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/01/02/css/">有趣的css</a>
          </li>
        
          <li>
            <a href="/2017/12/11/life/">life</a>
          </li>
        
          <li>
            <a href="/2017/12/05/前端基础知识点/">前端基础知识点整理</a>
          </li>
        
          <li>
            <a href="/2016/12/11/Jquery/">Jquery</a>
          </li>
        
          <li>
            <a href="/2015/09/09/搭建自己的博客/">搭建自己的博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 猫咪桑<br>
      Construido por <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">猫猫的爬坑路</a>
  
    <a href="/archives" class="mobile-nav-link">碎碎念</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>